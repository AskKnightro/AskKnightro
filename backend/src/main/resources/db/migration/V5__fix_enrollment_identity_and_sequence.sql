-- V5__fix_enrollment_identity_and_sequence.sql
-- Make enrollment_id auto-increment safely across environments (serial or identity)
-- and sync the sequence to MAX(enrollment_id).

-- 1) If NOT already identity, make it identity (no-op if already identity)
DO $$
    DECLARE
        is_identity boolean;
    BEGIN
        SELECT (identity_generation IS NOT NULL)
        INTO   is_identity
        FROM   information_schema.columns
        WHERE  table_schema = 'public'
          AND  table_name   = 'enrollment'
          AND  column_name  = 'enrollment_id';

        IF NOT is_identity THEN
            -- Will error if already identity; hence guarded by the check above.
            ALTER TABLE enrollment
                ALTER COLUMN enrollment_id
                    ADD GENERATED BY DEFAULT AS IDENTITY;
        END IF;
    END $$;

-- 2) If still NOT identity, ensure a default nextval exists (older schemas)
DO $$
    BEGIN
        IF EXISTS (
            SELECT 1
            FROM information_schema.columns
            WHERE table_schema = 'public'
              AND table_name   = 'enrollment'
              AND column_name  = 'enrollment_id'
              AND identity_generation IS NULL
              AND (column_default IS NULL OR column_default NOT LIKE 'nextval(%')
        ) THEN
            IF NOT EXISTS (
                SELECT 1
                FROM pg_sequences
                WHERE schemaname  = 'public'
                  AND sequencename = 'enrollment_enrollment_id_seq'
            ) THEN
                CREATE SEQUENCE enrollment_enrollment_id_seq;
            END IF;

            ALTER TABLE enrollment
                ALTER COLUMN enrollment_id
                    SET DEFAULT nextval('enrollment_enrollment_id_seq');
        END IF;
    END $$;

-- 3) Advance whichever sequence is OWNED by enrollment.enrollment_id to MAX(id)
--    Works for both serial and identity without relying on pg_get_identity_sequence().
DO $$
    DECLARE
        seq regclass;
    BEGIN
        -- Try the standard helper first (works for serial; sometimes for identity too)
        SELECT pg_get_serial_sequence('enrollment','enrollment_id')::regclass
        INTO   seq;

        -- If that returned NULL, find the owned sequence via pg_depend
        IF seq IS NULL THEN
            SELECT s.oid::regclass
            INTO   seq
            FROM   pg_class s
                       JOIN pg_namespace ns ON ns.oid = s.relnamespace
                       JOIN pg_depend d     ON d.objid = s.oid AND d.deptype = 'a'  -- owned by
                       JOIN pg_attrdef ad   ON ad.oid = d.refobjid
                       JOIN pg_attribute a  ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum
            WHERE  ns.nspname   = 'public'
              AND  s.relkind    = 'S'              -- sequence
              AND  a.attrelid   = 'enrollment'::regclass
              AND  a.attname    = 'enrollment_id'
            LIMIT 1;
        END IF;

        -- If we found a sequence, bump it to MAX(enrollment_id)
        IF seq IS NOT NULL THEN
            EXECUTE format(
                    'SELECT setval(%L, (SELECT COALESCE(MAX(enrollment_id),1) FROM enrollment), true)',
                    seq::text
                    );
        END IF;
    END $$;